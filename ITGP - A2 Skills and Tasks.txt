# Assignment 2.2 - Available Skills/Tasks to Choose from

___

# 2D/3D Visual Artist Skills
VA01: Import 2D and 3D assets from an external program into a game engine, the asset must show in a level and be visible in the ‘game world’. 2D Image must show transparency. 3D Asset must be unwrapped, textured, and also show transparency.

VA02: Import and work with sprite sheet animations into a game engine. Sprite sheet must loop in its animation, and demonstrate transparency. Also look into how to make sprites not loop and only play once. Spritesheet must be visible when the game is running.

VA03: Import a 3D animated object, and have its animation looped in the running game. Also look into how to make the animation a ‘one shot’ (plays only once).

VA04: Import a rigged and skinned/vertex weighted 3D object, and have its animation looped in the running game. Also look into how to make the animation a ‘one shot’ (plays only once).

VA05: Animate using keyframes for 2D and 3D objects *within* the game engine itself (not using an external program). These animations need to be able to play in the running game. (Note that not all engines support an in-editor animator, so this option may not be available to you)

VA06: Create one permanent/looping  particle system, and one ‘one shot’ particle system, within the engine itself. The particles must demonstrate transparency, no shadows, and a custom texture/image, and motion. This needs to be visible in the running game.

* VA07: Create a 3D  ‘arena’ or room, using only the engine, without any external programs. Plugins or addons are allowed. There needs to be a minimum of 5 materials/textures created in the engine that are applied to the arena/room.

VA08: Create a UI using UI specific objects in the game engine. Some engines have “Canvas” objects or “UI” objects. Create a game user interface using these UI specific objects.

VA09: Create a 3D dark room, and demonstrate various different lighting objects. This needs to be visible in the running game. Explore ways to achieve volumetric light to see if your engine supports it. Also explore light emitting materials.

VA10: Explore ‘Rigid Bodies’ in the engine and build a structure that, when the game is played, has objects falling to gravity and show collisions and physics. Eg. A see saw/balance beam with objects of different sizes/masses falling on them at run time. Also demonstrate rigid bodies that are ‘kinematic’ (i.e. they do not move but things still collide with them.

VA11: Search for generative mesh plugins and create a scene/level with it. Eg. Forest generators, terrain generators, greeble generators. This must be a plugin for the game engine, and not something like a 3d modelling software like Blender/Maya/3dsMax.


___

# Audio/Sound, and Music

 * AU01: Import sound files into the engine. Figure out a way to trigger one-shot sounds, and have looping sounds. You will also need to figure out how to trigger the sounds when the user interacts in the game with either a keypress or mouse click.

AU02: Explore the engine and/or find plugins to enable audio mixing and live-audio effects, such as reverb, delay, pitch shifting, EQ, and other  effects. Find at least two effects that are working when the game is running.

AU03: Explore the engine and search for ways to get MIDI files to play in a running game. You may need to also search for plugins, and might need to learn about soundfonts as well.

AU04: Explore the engine and search for ways to stream audio into the running game (such as streaming from an online radio station).  You may need to search for plugins to support this feature.

AU05: Explore the engine and search for whether VST or LV2 plugins can be loaded into the engine. You may need to search for plugins to support this feature.

AU06: Explore the engine and search for audio visualiser plugins, such as audio spectrometers, waveform visualisers, and mic level monitors, that can be visible in the running game.


___

# Code and Programming

 * PR01: UI Programming. Set up a basic canvas, and hook into the button click events (with the mouse, but you’re welcome to explore keyboard or gamepad events too).

PR02: Object manipulation. React to user inputs (such as mouse click or keyboard/gamepad) to do each of the following, with different events for:: A) Hide/show a game object. B) Create/instantiate a game object. C) Delete/destroy a game object.

PR03: Scene and settings:  React to user inputs (such as mouse click or keyboard/gamepad) to do each of the following, with different events for: A) Switch screens/levels/scenes/worlds (and switch back). B) Exit the game, C) Change game settings such as volume, resolution/window size, fullscreen/windowed

PR03: Input handling. Most game engines have input managers. Instead of hard coding things like “if KeyPressed(Key.Space)”, use the input manager for your event handling (i.e. ‘if ButtonPressed(“Jump”)). You must be able to demonstrate how to get analog inputs (eg. X/Y/Z axis) as well as button inputs (ABXY etc.)

 * PR04: Physics programming: Manipulate and move an object/player character using forces in the rigid body system of the engine. Must be able to move around such as WASD, and also jump, and ‘respawn’/reset position.

PR05: Game mechanics: Create or import a template project for a genre of your choice. You’re welcome to ask your team what kind of genre if you’re not fussed about what type of game to look into. (eg. First person, 2d platformer, 3d platformer, etc…) Explore and manipulate the template to demonstrate being able to customise the mechanics - this skill MUST be combined with other PR## skills of your choice.

PR06: Physics programming: React to a collision event and create an object at the collision location. A sound effect needs to also play when the collision happens.

PR07: Timers and delays: Make an object delete itself after a few seconds after being created. Implement this two ways: one with coroutines/threads/timers provided by the engine. The other way with a float variable that counts down based on time passing.

PR10: Game mechanics: You can discuss a mechanic with your tutor and come up with your own! Objects deleting when they have zero health, increasing a global score variable when certain conditions are met, etc…

PR11: Technical programmer: Assist a team member with setting up a project/task that involves working with a template/example project, and hook that project into one other programming.


___

# Design and Testing

 * DT01: Create or import a game template, and manipulate the character’s properties to simulate different ‘player effects’: A) ‘slowed movement’, B) ‘doubled/halved jump height’, C) Tweak cooldowns or animation speeds, if any.

DT02: Usability Configuration: A) remap controller or keyboard/mouse buttons to different actions, B) Change axis sensitivity for mouse looking C) Change axis sensitivity for gamepad inputs. Note that you may need different templates to fulfil mouse/gamepad sensitivities.

DT03: Build/export the game, so that it’s able to run without the need for the game engine to run. Export and test for at least two different platforms that you can get access to yourself (eg. PC, Linux, Mac, Web, Android, iOS, etc..)

DT04: Testing and mechanics balancing: Explore and search for plugins for your engine that can emulate/simulate game inputs for automated scenario testing.

DT05: Testing and user experience: Explore and search for game-input loggers that shows or logs user inputs when the game is running. See if there are features to export the data to a file for analysis later.


___

# Writing

WR01: Localisation: Explore how your engine handles localisation, and demonstrate at least two different localisation entries. You may need to search for plugins or templates to demonstrate this.

WR02: Dialogue system plugins: Explore and find dialogue system plugins, and try at least one template/example project.

WR03: With a project and dialogue system of your choice, create/implement at least one dialog tree or dialog variation. This needs to combine with another writer’s skill.

WR04: Explore and search for plugins or templates for NPCs that ‘bark’ (or say dialogue over their heads, for example) periodically. Edit the dialogue that the NPCs say, and edit the name of the NPCs as well.
